<!doctype html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Carrossel infinito A4 + Zoom real</title>

    <style>
        :root{
            --gapX: 100px;
            --tiltY: 14deg;
            --depth: 120px;
            --sideScale: 0.88;
            --centerScale: 1.0;
            --lift: 0px;
        }

        *{ box-sizing:border-box; }

        body{
            margin:0;
            font-family:system-ui, sans-serif;
            background:#0f1220;
            color:#fff;
        }

        /* ===== CARROSSEL ===== */
        .carousel{
            position:relative;
            width:96vw;
            height:80vh;
            margin:40px auto;
            border-radius:18px;
            background:#14182e;
            overflow:hidden;
        }
        .viewport{
            position:absolute;
            inset:0;
            perspective:1100px;
            perspective-origin: 50% 40%;
        }
        .belt{
            position:relative;
            width:100%;
            height:100%;
            transform-style:preserve-3d;
        }
        .pageImg{
            position:absolute;
            top:50%;
            left:50%;
            max-width:25vw;
            max-height:72vh;
            width:auto;
            height:auto;
            background:#fff;
            border-radius:10px;
            box-shadow:0 12px 28px rgba(0,0,0,.30);
            transform-style:preserve-3d;
            transition:transform .42s cubic-bezier(.2,.9,.2,1), filter .25s ease;
            cursor:default;
            user-select:none;
            -webkit-user-drag:none;
        }
        .pageImg[data-active="true"]{
            filter:brightness(1.05);
            cursor:zoom-in;
        }

        /* ===== SETAS ===== */
        .controls{
            position:absolute;
            inset:0;
            pointer-events:none;
        }
        .controls button{
            pointer-events:auto;
            position:absolute;
            top:50%;
            transform:translateY(-50%);
            border:none;
            background:rgba(0,0,0,.6);
            color:#fff;
            width:52px;
            height:52px;
            border-radius:50%;
            cursor:pointer;
            font-size:22px;
        }
        #prev{ left:12px; }
        #next{ right:12px; }

        /* ===== MODAL ===== */
        .modal{
            position:fixed;
            inset:0;
            display:none;
            background:rgba(0,0,0,.7);
            z-index:999;
        }
        .modal.open{ display:block; }

        .modalContent{
            position:absolute;
            inset:40px;
            background:#111;
            border-radius:16px;
            display:flex;
            flex-direction:column;
        }
        .modalTop{
            padding:10px;
            display:flex;
            justify-content:flex-end;
            gap:8px;
        }
        .modalTop button{
            background:#222;
            border:none;
            color:#fff;
            padding:8px 12px;
            border-radius:8px;
            cursor:pointer;
        }

        /* ===== ZOOM REAL + PAN ===== */
        .modalCanvas{
            flex:1;
            overflow:auto;
            background:#000;

            cursor:grab;
            user-select:none;
            touch-action:none; /* necessário p/ pinch + pan manual */
        }
        .modalCanvas.grabbing{ cursor:grabbing; }

        .modalCanvas img{
            display:block;
            margin:auto;
            pointer-events:none;
            user-select:none;
            -webkit-user-drag:none;
        }

        /* ===== AJUSTE PARA CELULAR EM PÉ (PORTRAIT) ===== */
        @media (max-width: 768px) and (orientation: portrait) {

            :root{
                --gapX: 42px;     /* aproxima as páginas */
                --depth: 70px;    /* reduz profundidade 3D */
                --tiltY: 8deg;    /* menos inclinação */
                --sideScale: 0.92;
            }

            .carousel{
                height: 78vh; /* evita “esticar” demais */
            }

            .pageImg{
                max-width: 68vw;   /* páginas mais largas no celular */
                max-height: 70vh;
            }

            /* Setas fora da área das páginas */
            .controls{
                pointer-events:none;
            }

            .controls button{
                top: auto;
                bottom: 14px;
                transform: none;
                pointer-events:auto;
                width:48px;
                height:48px;
            }

            #prev{ left: 14px; }
            #next{ right: 14px; }
        }

        @media (max-width: 768px) and (orientation: portrait){
            .belt{ touch-action: pan-y; }
        }


    </style>
</head>

<body>

<div class="carousel">
    <div class="viewport">
        <div class="belt" id="belt">
            <img class="pageImg" src="./img/1.png" alt="1" draggable="false">
        </div>
    </div>

    <div class="controls">
        <button id="prev">◀</button>
        <button id="next">▶</button>
    </div>
</div>

<!-- MODAL -->
<div class="modal" id="modal">
    <div class="modalContent">
        <div class="modalTop">
            <button id="zoomOut">−</button>
            <button id="zoomIn">+</button>
            <button id="close">✕</button>
        </div>
        <div class="modalCanvas" id="canvas">
            <img id="modalImg" draggable="false" alt="zoom">
        </div>
    </div>
</div>

<script>
    (() => {
        const pages = [...document.querySelectorAll('.pageImg')];
        const belt = document.getElementById('belt');

        const modal = document.getElementById('modal');
        const modalImg = document.getElementById('modalImg');
        const canvas = document.getElementById('canvas');

        const mod = (n,m)=>((n % m) + m) % m;

        // índice real infinito
        let activeReal = 0; // começa na imagem 1

        // ===== CARROSSEL (infinito de verdade) =====
        function render(){
            const n = pages.length;
            const activeIndex = mod(activeReal, n);
            const half = Math.floor(n/2);

            const root = getComputedStyle(document.documentElement);
            const gapX = parseFloat(root.getPropertyValue('--gapX')) || 100;
            const tiltY = parseFloat(root.getPropertyValue('--tiltY')) || 14;
            const depth = parseFloat(root.getPropertyValue('--depth')) || 120;
            const sideScale = parseFloat(root.getPropertyValue('--sideScale')) || 0.88;
            const centerScale = parseFloat(root.getPropertyValue('--centerScale')) || 1.0;
            const lift = parseFloat(root.getPropertyValue('--lift')) || 0;

            pages.forEach((img, i) => {
                // diferença circular sempre em [-half, +half]
                let d = i - activeIndex;
                if (d >  half) d -= n;
                if (d < -half) d += n;

                const abs = Math.abs(d);
                const dir = Math.sign(d);

                const x = d * gapX;
                const y = (d === 0) ? -lift : 0;
                const z = -abs * depth;
                const rotY = (d === 0) ? 0 : (-dir * tiltY);
                const sc = (d === 0) ? centerScale : sideScale;

                img.dataset.active = (d === 0) ? "true" : "false";
                img.style.zIndex = String(1000 - abs);

                img.style.transform =
                    `translate(-50%,-50%) translate3d(${x}px, ${y}px, ${z}px) rotateY(${rotY}deg) scale(${sc})`;

                img.style.filter = (d === 0) ? 'none' : `brightness(${0.92 - abs*0.03})`;
            });
        }

        function go(delta){
            activeReal += delta;
            render();
        }

        document.getElementById('prev').onclick = ()=> go(-1);
        document.getElementById('next').onclick = ()=> go(1);

        // wheel do carrossel (navega infinito sem deslocar)
        let wheelLock = false;
        belt.addEventListener('wheel', (e) => {
            if (modal.classList.contains('open')) return;
            e.preventDefault();

            if (wheelLock) return;
            wheelLock = true;
            setTimeout(() => wheelLock = false, 90);

            const use = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;
            if (use > 0) go(1);
            else go(-1);
        }, { passive:false });

// ===== SWIPE NO CELULAR (deslizar o dedo = 1 página) =====
        let swipeStartX = null;
        let swipeStartY = null;
        let swipeStartT = 0;

        belt.addEventListener('touchstart', (e) => {
            if (modal.classList.contains('open')) return;
            if (!e.touches || e.touches.length !== 1) return;

            swipeStartX = e.touches[0].clientX;
            swipeStartY = e.touches[0].clientY;
            swipeStartT = Date.now();
        }, { passive: true });

        belt.addEventListener('touchend', (e) => {
            if (modal.classList.contains('open')) return;
            if (swipeStartX == null || swipeStartY == null) return;

            const t = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : null;
            if (!t) return;

            const endX = t.clientX;
            const endY = t.clientY;

            const dx = endX - swipeStartX;
            const dy = endY - swipeStartY;
            const dt = Date.now() - swipeStartT;

            swipeStartX = swipeStartY = null;

            // Ignora se foi mais vertical que horizontal
            if (Math.abs(dx) < Math.abs(dy)) return;

            // Config do gesto
            const MIN_DIST = 35;     // distância mínima em px
            const MAX_TIME = 700;    // tempo máximo do gesto em ms

            if (Math.abs(dx) < MIN_DIST) return;
            if (dt > MAX_TIME) return;

            // Swipe para esquerda => próxima página
            if (dx < 0) go(1);
            else go(-1);
        }, { passive: true });

        // ===== MODAL =====
        // zoomFactor = 1 significa "tamanho normal" (fit na tela)
        let zoomFactor = 1;
        let baseW = 0;
        let baseH = 0;
        let baseScale = 1; // calculado para caber no canvas
        const minZoomFactor = 1;   // começa normal e não deixa diminuir abaixo do fit (ajuste se quiser)
        const maxZoomFactor = 8;

        function computeBaseScaleFit(){
            // margem para não encostar nas bordas
            const margin = 24;
            const cw = Math.max(1, canvas.clientWidth - margin * 2);
            const ch = Math.max(1, canvas.clientHeight - margin * 2);

            // fit total dentro do canvas (sem aumentar acima de 1 por padrão)
            const fit = Math.min(cw / baseW, ch / baseH, 1);
            baseScale = fit;
        }

        function applyZoom(){
            const scale = baseScale * zoomFactor;
            modalImg.style.width  = (baseW * scale) + 'px';
            modalImg.style.height = (baseH * scale) + 'px';
        }

        pages.forEach(img=>{
            img.onclick = () => {
                // sem clique lateral: só abre se for a central
                if (img.dataset.active !== "true") return;

                modalImg.src = img.src;
                modal.classList.add('open');

                // inicia SEMPRE no tamanho normal (fit)
                zoomFactor = 1;

                modalImg.onload = () => {
                    baseW = modalImg.naturalWidth || 1;
                    baseH = modalImg.naturalHeight || 1;

                    computeBaseScaleFit();
                    applyZoom();

                    // volta o scroll para o centro no início
                    requestAnimationFrame(() => {
                        canvas.scrollTop  = (canvas.scrollHeight - canvas.clientHeight) / 2;
                        canvas.scrollLeft = (canvas.scrollWidth - canvas.clientWidth) / 2;
                    });
                };
            };
        });

        document.getElementById('close').onclick = closeModal;
        modal.onclick = (e)=>{ if (e.target === modal) closeModal(); };
        function closeModal(){ modal.classList.remove('open'); }

        document.getElementById('zoomIn').onclick = ()=> {
            zoomFactor = Math.min(maxZoomFactor, zoomFactor * 1.2);
            applyZoom();
        };
        document.getElementById('zoomOut').onclick = ()=> {
            zoomFactor = Math.max(minZoomFactor, zoomFactor / 1.2);
            applyZoom();
        };

        // Se o usuário girar a tela / redimensionar: recalcula fit sem mudar o zoomFactor atual
        window.addEventListener('resize', () => {
            if (!modal.classList.contains('open')) return;
            computeBaseScaleFit();
            applyZoom();
        });

        // ===== ZOOM NO SCROLL (APENAS NO MODAL) =====
        canvas.addEventListener('wheel', (e) => {
            if (!modal.classList.contains('open')) return;
            e.preventDefault();

            const factor = (e.deltaY < 0) ? 1.08 : (1 / 1.08);
            zoomFactor = Math.min(maxZoomFactor, Math.max(minZoomFactor, zoomFactor * factor));
            applyZoom();
        }, { passive:false });

        // ===== PAN (mouse: segurar e arrastar) =====
        let isPanningMouse = false;
        let startX = 0, startY = 0;
        let startScrollLeft = 0, startScrollTop = 0;

        canvas.addEventListener('pointerdown', (e) => {
            // pan com mouse apenas (no touch usamos touch events abaixo)
            if (e.pointerType !== 'mouse') return;
            if (e.button !== 0) return;
            e.preventDefault();

            isPanningMouse = true;
            canvas.classList.add('grabbing');

            startX = e.clientX;
            startY = e.clientY;
            startScrollLeft = canvas.scrollLeft;
            startScrollTop = canvas.scrollTop;

            canvas.setPointerCapture(e.pointerId);
        });

        canvas.addEventListener('pointermove', (e) => {
            if (!isPanningMouse) return;

            const dx = e.clientX - startX;
            const dy = e.clientY - startY;

            canvas.scrollLeft = startScrollLeft - dx;
            canvas.scrollTop  = startScrollTop  - dy;
        });

        canvas.addEventListener('pointerup', (e) => {
            isPanningMouse = false;
            canvas.classList.remove('grabbing');
            try { canvas.releasePointerCapture(e.pointerId); } catch {}
        });

        canvas.addEventListener('pointercancel', () => {
            isPanningMouse = false;
            canvas.classList.remove('grabbing');
        });

        // ===== PINCH (celular) + PAN 1 dedo =====
        let tPanning = false;
        let tStartX = 0, tStartY = 0;
        let tStartScrollLeft = 0, tStartScrollTop = 0;

        let pinching = false;
        let pinchStartDist = 0;
        let pinchStartZoom = 1;

        function dist(t1, t2){
            const dx = t2.clientX - t1.clientX;
            const dy = t2.clientY - t1.clientY;
            return Math.hypot(dx, dy);
        }

        canvas.addEventListener('touchstart', (e) => {
            if (!modal.classList.contains('open')) return;

            if (e.touches.length === 1){
                // pan com 1 dedo
                pinching = false;
                tPanning = true;

                tStartX = e.touches[0].clientX;
                tStartY = e.touches[0].clientY;
                tStartScrollLeft = canvas.scrollLeft;
                tStartScrollTop = canvas.scrollTop;
            }

            if (e.touches.length === 2){
                // pinch
                tPanning = false;
                pinching = true;

                pinchStartDist = dist(e.touches[0], e.touches[1]);
                pinchStartZoom = zoomFactor;
            }
        }, { passive: true });

        canvas.addEventListener('touchmove', (e) => {
            if (!modal.classList.contains('open')) return;

            if (pinching && e.touches.length === 2){
                e.preventDefault();

                const d = dist(e.touches[0], e.touches[1]);
                if (pinchStartDist <= 0) return;

                const ratio = d / pinchStartDist;
                zoomFactor = Math.min(maxZoomFactor, Math.max(minZoomFactor, pinchStartZoom * ratio));
                applyZoom();
                return;
            }

            if (tPanning && e.touches.length === 1){
                e.preventDefault();

                const dx = e.touches[0].clientX - tStartX;
                const dy = e.touches[0].clientY - tStartY;

                canvas.scrollLeft = tStartScrollLeft - dx;
                canvas.scrollTop  = tStartScrollTop  - dy;
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (e.touches.length === 0){
                tPanning = false;
                pinching = false;
            }
            if (e.touches.length === 1){
                // saiu do pinch e ficou 1 dedo: volta a pan
                pinching = false;
                tPanning = true;

                tStartX = e.touches[0].clientX;
                tStartY = e.touches[0].clientY;
                tStartScrollLeft = canvas.scrollLeft;
                tStartScrollTop = canvas.scrollTop;
            }
        }, { passive: true });

        render();
    })();
</script>

</body>
</html>
